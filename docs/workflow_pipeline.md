# Полный пайплайн работы в редакторе NovelMind

Цель: описать полный путь разработчика (от запуска редактора до play),
а также зафиксировать текущую архитектуру редактора и ее границы.
Документ описывает **реализованный** пайплайн и отдельный блок Next для
последующих улучшений.

## 0. Принципы

1. Один источник истины для контента. Визуальное редактирование и NMScript
   не должны расходиться.
2. WYSIWYG = максимально единый путь от данных до рендера (с оговорками ниже).
3. Каждое действие игрока в play должно быть воспроизводимо (детерминизм).
4. Никаких "пустых" запусков: при play всегда видим текущий узел/сцену.

## 1. Пайплайн разработчика (полный путь)

### 1.1 Старт и создание проекта
1) Запуск редактора -> Welcome.
2) Новый проект:
   - Шаблон (кинетик, с выбором, интерактивный).
   - Имя, путь, базовое разрешение, язык по умолчанию.
3) Генерация структуры:
   - `Assets/`, `Scenes/`, `Scripts/`, `Localization/`, `Build/`.
   - `project.json`, стартовый `main.nms`, пустая стартовая сцена.
4) Открытие проекта и автосохранение настроек окна.

### 1.2 Базовые настройки (перед контентом)
1) Project Settings:
   - Разрешение, безопасная зона, базовая шрифтовая тема, скорость текста.
2) Настройка путей:
   - Папки ассетов, локализация, экспортные профили.
3) Валидация:
   - Есть ли стартовая сцена? Есть ли entry-узел?

### 1.3 Импорт ассетов
1) Drag & drop в Asset Browser.
2) Для каждого файла:
   - Создается метадата (id, type, source path, imported path).
   - Миниатюры/формы волн добавляются при включенной генерации (если доступно).
3) Ошибки импорта:
   - Показываются в Diagnostics + предупреждение в UI.
4) Поведение при переименовании:
   - ID стабилен для уже импортированного пути. Переименование файла
     через проводник ОС считается новой сущностью (v2: умное сопоставление).

### 1.4 Story Graph (нарративный поток)
1) Создать Entry и подключить к стартовой сцене.
2) Добавить узлы:
   - Scene Node, Dialogue Node, Choice, Code, Jump, End.
3) У каждого узла:
   - Заголовок, краткое описание, ссылка на сцену/скрипт.
4) Визуальные связи:
   - Поддержка условных переходов и дефолтного пути.

### 1.5 "Войти" в узел и редактировать сцену
1) В Story Graph — двойной клик по Scene/Dialogue узлу.
2) Открывается Scene Editor для текущего `sceneId`.
3) Внутри сцены:
   - Фон, персонажи, UI, эффекты, z‑порядок, трансформы.
4) Сцена хранится в `.nmscene` как полный слой (дельты узлов — v2).

### 1.6 Работа с NMScript
1) Script Editor открывает `.nms` файлы напрямую.
2) Story Graph узлы привязаны к сценам и переходам; код правится отдельно.
3) Diagnostics панели показывают ошибки валидатора (если включен).

### 1.7 Preview / Play
1) Режимы:
   - Preview (статический рендер текущей сцены).
   - Play (полный runtime).
   - Step (пошагово: кадр/строка/инструкция).
2) Запуск:
   - Play from Entry.
   - Play from Node (текущий узел).
3) Во время play:
   - Scene View отображает runtime snapshot.
   - Dialogue/Choice overlay реагирует на вход.
   - Доступны save/load (слоты + авто-сейв).
4) Остановка:
   - Возврат в режим редактирования.
   - Очистка runtime объектов.

### 1.8 Итерации
1) Быстрое исправление сцены -> play from node.
2) Build/Export описаны в отдельном документе (в рамках этого этапа не исполняются).

## 2. Scene Graph (текущее состояние)

### 2.1 Главная идея
Сейчас редактор хранит сцену как единый слой, runtime использует snapshot.
Разделение ASG/RSG остается целевым улучшением (см. Next).

### 2.2 Authoring Scene Graph (ASG)
- Scene -> Objects (Sprite/Transform/FX) в `.nmscene`.
- Полный state сохранен в проекте.

### 2.3 Runtime Scene Graph (RSG)
- Создается при play (runtime host).
- Дает SceneSnapshot для UI/preview.

### 2.4 Дельты узлов (Scene Node Overrides)
Планируемая функция (Next). Сейчас сцена хранится целиком.

## 3. Play Mode (детально)

### 3.1 Состояния
Stopped -> Running -> Paused -> Stepping -> Stopped.
В каждом состоянии:
- Playing: runtime тик + snapshot
- Paused: только UI, без тика
- Stepping: tick по запросу

### 3.2 Контроль запуска
1) Проверка проекта (assets/scripts/scenes).
2) Компиляция NMScript в IR.
3) Создание Runtime Scene Graph.
4) Старт из Entry или выбранного узла.

### 3.3 Интеграция с редактором
- Scene View рендерит snapshot (RSG).
- Story Graph подсвечивает текущий узел.
- Inspector показывает runtime-only (read-only).

## 4. Preview (WYSIWYG)

### 4.1 Основная проблема
WYSIWYG ломается, если используются разные пути рендера.
Сейчас: editor использует QGraphicsView, runtime snapshot — GL превью.

### 4.2 Режимы превью
1) Edit Preview:
   - Рендер editor-сцены (QGraphicsView).
2) Play Preview:
   - Рендер runtime snapshot (GL viewport).

### 4.3 Экспорт snapshot
Snapshot содержит:
- background, visibleCharacters, objects
- dialogue/choices
- camera state

## 5. Renderer (пересмотр)

### 5.1 Единый пайплайн
Цель: SceneGraph -> RenderGraph -> CommandQueue -> GPU.
Текущее состояние: editor использует QGraphicsView, runtime — OpenGL snapshot.

### 5.2 Практическая схема
- Renderer backend: SDL2/OpenGL (как уже начато).
- Scene objects -> Renderables (Sprite/Text/FX).
- UI overlay (dialogue/choices) как отдельный слой.

### 5.3 Гарантия WYSIWYG
Если объект видно в editor, он точно так же виден в runtime.

## 6. Вопросы и ответы (критические мелочи)

Q: Что считается источником истины: Scene Graph или NMScript?
A: Авторинг хранится в проекте (ASG + Story Graph). NMScript — производное,
   но редактируемое. Синхронизация в обе стороны.

Q: Что происходит при редактировании кода во время play?
A: Редактирование разрешено, но изменения применяются после stop или
   через "hot reload" (опционально).

Q: Где живет диалог/текст?
A: Как часть Story Node + локальный override.

Q: Что делать, если фон отсутствует?
A: Рендерер показывает placeholder + error в Diagnostics.

Q: Что показывать при play без entry?
A: Play невозможен -> явная ошибка.

Q: Что если Scene Node не имеет дельт?
A: Используется базовая сцена без изменений.

Q: Можно ли запускать play из узла?
A: Да. Runtime создается, затем применяются дельты из узла,
   затем запускается скрипт с этого узла.

Q: Как избежать несоответствия Story Graph и NMScript?
A: Сохранять стабильные идентификаторы узлов и привязку к строкам кода.

Q: Как хранить "вход" в узел?
A: NodeRef = {sceneId, nodeId, scriptLocation}.

Q: Как управлять временем (анимация/таймлайн)?
A: Таймлайн хранит треки, а runtime во время play тикает их.

## 7. Режимы работы с контентом (Workflow Modes)

NovelMind поддерживает три основных режима создания контента. Выберите тот,
который лучше подходит вашему стилю работы.

### 7.1 Режим 1: Только код (Code-First)

**Для кого:** Программисты, опытные пользователи, сложные проекты.

**Workflow:**
1. Создайте `.nms` файлы напрямую в Script Editor.
2. Story Graph автоматически анализирует `scene`, `goto`, `choice` в коде.
3. Используйте кодовые конструкции для полного контроля логики.

**Преимущества:**
- Полный контроль над логикой и структурой.
- Поддержка версионирования (git/svn).
- Быстрое редактирование для опытных пользователей.

**Особенности:**
- Идентификаторы сцен должны быть валидными (буквы, цифры, подчеркивания).
- Поддерживаются Unicode-идентификаторы (кириллица, греческий, CJK и др.).

### 7.2 Режим 2: Только граф (Visual-First)

**Для кого:** Нарратив-дизайнеры, сценаристы, быстрое прототипирование.

**Workflow:**
1. Создавайте узлы в Story Graph (Scene, Dialogue, Choice).
2. Редактируйте свойства в Inspector (спикер, текст, варианты выбора).
3. Система автоматически генерирует `.nms` файлы.
4. Используйте "Sync to Script" для обновления кода.

**Преимущества:**
- Визуальное понимание нарратива.
- Не нужно знать синтаксис NMScript.
- Быстрый старт для новичков.

**Особенности:**
- ID узлов автоматически санитизируются (числа в начале, спецсимволы).
- Генерированный код помечен комментарием "Generated from Story Graph".
- Изменения в коде могут быть перезаписаны при синхронизации.

### 7.3 Режим 3: Гибридный (Mixed)

**Для кого:** Продвинутые пользователи, средние и большие проекты.

**Workflow:**
1. Создайте структуру нарратива в Story Graph.
2. Реализуйте сложную логику в Script Editor.
3. Синхронизируйте при необходимости.

**Преимущества:**
- Лучшее из обоих миров.
- Визуальный обзор + мощность кода.
- Гибкость в выборе инструментов.

**Рекомендации:**
- Не редактируйте сгенерированные файлы вручную.
- Используйте отдельные `.nms` файлы для сложной логики.
- Разделяйте сцены: "визуальные" (через граф) и "логические" (через код).

### 7.4 Идентификаторы и Unicode

NMScript теперь полностью поддерживает Unicode-идентификаторы:

```nmscript
// Примеры валидных идентификаторов:
scene пролог { ... }
character Алексей(name="Алексей", color="#4A9FD9")
scene 導入 { ... }  // Японский
scene εισαγωγή { ... }  // Греческий

// Примеры невалидных идентификаторов:
// scene 123test { ... }  // Начинается с цифры - автоматически исправится
// scene my-scene { ... } // Дефис недопустим
```

Система автоматически преобразует невалидные идентификаторы:
- `123test` → `_123test_1` (добавляется подчеркивание)
- `my-scene` → `my_scene_1` (дефис заменяется)
- Пустые строки → `node_1` (используется дефолт)

### 7.5 Синхронизация Graph ↔ Script

**Graph → Script** (кнопка "Sync to Script"):
- Обновляет `say` statements в существующих сценах.
- Создает новые `.nms` файлы для новых узлов.
- Добавляет `// @graph-begin ... // @graph-end` блоки для переходов.

**Script → Graph** (автоматически при открытии):
- Парсит `scene`, `goto`, `choice` конструкции.
- Создает узлы и связи в Story Graph.
- Восстанавливает позиции из `story_graph.json`.

**Важно:** При конфликте приоритет имеет источник, из которого
выполняется синхронизация.
